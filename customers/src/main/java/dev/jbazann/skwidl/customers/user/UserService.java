package dev.jbazann.skwidl.customers.user;

import dev.jbazann.skwidl.customers.user.dto.NewUserDTO;
import dev.jbazann.skwidl.customers.user.dto.UserDTO;
import dev.jbazann.skwidl.customers.user.exceptions.InvalidUserException;
import jakarta.validation.Valid;
import jakarta.validation.constraints.NotNull;
import org.springframework.data.domain.Example;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.validation.annotation.Validated;

import java.util.ArrayList;
import java.util.List;
import java.util.UUID;

@Service
@Validated
public class UserService {

    private final UserRepository userRepository;

    public UserService(UserRepository userRepository) {
        this.userRepository = userRepository;
    }

    /**
     * User ID provider. Values generated by this method can be
     * expected to be unique and valid for registering new User instances.
     * @return a unique user entity identifier.
     */
    public UUID generateUserId() {
        UUID id;
        // TODO this is still terrible
        // be ffr though it's never going to collide, this is optimal
        while (userRepository.existsById(id = UUID.randomUUID()));
        return id;
    }

    public @NotNull @Valid User newUser(@Valid @NotNull NewUserDTO input) {
        UserDTO dto = input.toDto();
        dto.setId(generateUserId());
        dto.setCustomers(new ArrayList<>());
        @Valid User user = dto.toEntity();
        return userRepository.save(user);
    }

    /**
     * Set a user as allowed for a given customer. No customer ID validation will be performed (so
     * invalid references may exist)
     * @param customerId a customer ID that is presumed, but not required to be valid.
     * @param userId a valid user ID.
     * @return the updated {@link User} instance.
     */
    @SuppressWarnings("UnusedReturnValue")
    @Transactional// TODO
    public @NotNull @Valid User addAllowedUser(@NotNull UUID customerId, @NotNull UUID userId) {
        User user = fetchUser(userId);
        if(isEnabledFor(user, customerId)) {
            /* do not throw exception until decoupled from CustomerService
            throw new InvalidOperationException("User " + userId + " is already enabled for client " + customerId + '.') ;
            TODO log
             */
        }
        user.getCustomers().add(customerId);
        return userRepository.save(user);
    }

    /**
     * Find a list of up to 5 users matching the provided example.
     * This was made this way for simplicity's sake, only intended for queries
     * expected to match with a single user.
     * @param user an example user with null fields, except for those intended to be matched against.
     * @return a size-limited list of matching results.
     */
    public @NotNull List<@NotNull @Valid User> findUsersByExample(@NotNull User user) {
        return userRepository.findAll(Example.of(user), Pageable.ofSize(5)).toList();
    }

    private User fetchUser(UUID userId) {
        return userRepository.findById(userId).orElseThrow(
                () -> new InvalidUserException("User " + userId + " not found.")
        );
    }

    private boolean isEnabledFor(User user, UUID customerId) {
        return user.enabledForCustomerId(customerId);
    }

}
